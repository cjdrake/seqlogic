"""Advanced Encryption Standard.

See https://csrc.nist.gov/pubs/fips/197/final for details.
"""

# PyLint/PyRight are confused by MetaClass behavior
# pyright: reportArgumentType=false
# pyright: reportAttributeAccessIssue=false
# pyright: reportGeneralTypeIssues=false
# pyright: reportIndexIssue=false
# pyright: reportOperatorIssue=false
# pyright: reportReturnType=false

from collections import deque

from ..bits import Bits, stack
from ..vec import rep, uint2vec

NB = 4

Byte = Bits[8]
Text = Bits[4 * 32]

# Nk = {4, 6, 8}
Key = Bits[4, 32] | Bits[6, 32] | Bits[8, 32]
# Nr = {10, 12, 14}
RoundKeys = Bits[11, 4, 32] | Bits[13, 4, 32] | Bits[15, 4, 32]

Word = Bits[4, 8]
State = Bits[4, 32]
Matrix = Bits[4, 4, 4]


# fmt: off
_SBOX = [
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
]

_INV_SBOX = [
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
]

_RCON = [
    0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
    0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
    0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A,
    0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8,
    0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF,
    0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC,
    0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B,
    0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3,
    0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94,
    0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
    0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35,
    0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD, 0x61, 0xC2, 0x9F,
    0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB, 0x8D, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63,
    0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, 0x72, 0xE4, 0xD3, 0xBD,
    0x61, 0xC2, 0x9F, 0x25, 0x4A, 0x94, 0x33, 0x66, 0xCC, 0x83, 0x1D, 0x3A, 0x74, 0xE8, 0xCB,
]

_MTXA = [
    0x2311,
    0x1231,
    0x1123,
    0x3112,
]

_INV_MTXA = [
    0xEBD9,
    0x9EBD,
    0xD9EB,
    0xBD9E,
]
# fmt: on


# Convert raw data to bits
SBOX = stack(*[uint2vec(x, 8) for x in _SBOX])
INV_SBOX = stack(*[uint2vec(x, 8) for x in _INV_SBOX])

RCON = stack(*[uint2vec(x, 8) for x in _RCON])

MTXA = stack(*[uint2vec(x, 16) for x in _MTXA]).reshape(Matrix.shape)
INV_MTXA = stack(*[uint2vec(x, 16) for x in _INV_MTXA]).reshape(Matrix.shape)


def sub_word(w: Word) -> Word:
    """AES SubWord() function.

    Function used in the Key Expansion routine that takes a four-byte input word
    and applies an S-box to each of the four bytes to produce an output word.
    """
    return stack(*[SBOX[b.to_uint()] for b in w])


def inv_sub_word(w: Word) -> Word:
    """AES InvSubWord() function.

    Transformation in the Inverse Cipher that is the inverse of SubBytes().
    """
    return stack(*[INV_SBOX[b.to_uint()] for b in w])


def rot_word(w: Word) -> Word:
    """AES RotWord() function.

    Function used in the Key Expansion routine that takes a four-byte word and
    performs a cyclic permutation.
    """
    bs = deque(w)
    bs.rotate(-1)
    return stack(*bs)


def xtime(b: Byte, n: int) -> Byte:
    """Repeated polynomial multiplication in GF(2^8)."""
    for _ in range(n):
        b = (b << 1) ^ ("8h1B" & rep(b[7], 8))
    return b


def rowxcol(row: Bits[4, 4], col: Word) -> Bits:
    """Multiply one row and one column."""
    y = "8h00"
    for i in range(4):
        for j in range(4):
            # TODO(cjdrake): Fix ValueError
            if row[i, j]:
                y ^= xtime(col[3 - i], j)
    return y


def matmul(a: Matrix, col: Word) -> Bits:
    """Multiply a matrix by one column."""
    return stack(*[rowxcol(a[c], col) for c in range(NB)])


def mix_columns(state: State) -> State:
    """AES MixColumns() function.

    Transformation in the Cipher that takes all of the columns of the State and
    mixes their data (independently of one another) to produce new columns.
    """
    return stack(*[matmul(MTXA, state[c].reshape(Word.shape)) for c in range(NB)])


def inv_mix_columns(state: State) -> State:
    """AES InvMixColumns function.

    Transformation in the Inverse Cipher that is the inverse of MixColumns().
    """
    return stack(*[matmul(INV_MTXA, state[c].reshape(Word.shape)) for c in range(NB)])


def sub_bytes(state: State) -> State:
    """AES SubBytes() function.

    Transformation in the Cipher that processes the State using a nonÂ­linear
    byte substitution table (S-box) that operates on each of the State bytes
    independently.
    """
    ws = [sub_word(state[c].reshape(Word.shape)) for c in range(NB)]
    return stack(*ws)


def inv_sub_bytes(state: State) -> State:
    """AES InvSubBytes() function.

    Transformation in the Inverse Cipher that is the inverse of SubBytes().
    """
    ws = [inv_sub_word(state[c].reshape(Word.shape)) for c in range(NB)]
    return stack(*ws)


def shift_rows(state: State) -> State:
    """AES ShiftRows() function.

    Transformation in the Cipher that processes the State by cyclically shifting
    the last three rows of the State by different offsets.
    """
    rows = state.reshape((NB, 4, 8))

    bs = []
    cs = deque(range(NB))
    for _ in range(NB):
        for r in range(4):
            bs.append(rows[cs[r], r])
        cs.rotate(-1)

    return stack(*bs).reshape(State.shape)


def inv_shift_rows(state: State) -> State:
    """AES InvShiftRows() function.

    Transformation in the Inverse Cipher that is the inverse of ShiftRows().
    """
    rows = state.reshape((NB, 4, 8))

    bs = []
    cs = deque(reversed(range(NB)))
    for _ in range(NB):
        cs.rotate(1)
        for r in range(4):
            bs.append(rows[cs[r], r])

    return stack(*bs).reshape(State.shape)


def key_expansion(key: Key) -> RoundKeys:
    """Expand the key into the round key.

    See NIST FIPS 197 Section 5.2.
    """
    nk = len(key)
    nr = nk + 6
    assert nk in (4, 6, 8)

    ws = list(key)
    for i in range(nk, NB * (nr + 1)):
        temp = ws[i - 1].reshape(Word.shape)
        if i % nk == 0:
            temp = sub_word(rot_word(temp)) ^ RCON[i // nk].xt(8 * 3)
        elif nk > 6 and i % nk == 4:
            temp = sub_word(temp)
        ws.append(ws[i - nk] ^ temp)

    return stack(*ws).reshape(((nr + 1), 4, 32))


def cipher(pt: Text, rkeys: RoundKeys) -> Text:
    """AES encryption cipher.

    See NIST FIPS 197 Section 5.1.
    """
    nr = len(rkeys) - 1
    nk = nr - 6
    assert nk in (4, 6, 8)

    state = pt.reshape(State.shape)

    # first round
    state ^= rkeys[0]

    for i in range(1, nr):
        state = sub_bytes(state)
        state = shift_rows(state)
        state = mix_columns(state)
        state ^= rkeys[i]

    # final round
    state = sub_bytes(state)
    state = shift_rows(state)
    state ^= rkeys[nr]

    return state.reshape(Text.shape)


def inv_cipher(ct: Text, rkeys: RoundKeys) -> Text:
    """AES decryption cipher.

    SEE NIST FIPS 197 Section 5.3.
    """
    nr = len(rkeys) - 1
    nk = nr - 6
    assert nk in (4, 6, 8)

    state = ct.reshape(State.shape)

    # first round
    state ^= rkeys[nr]

    for i in range(nr - 1, 0, -1):
        state = inv_shift_rows(state)
        state = inv_sub_bytes(state)
        state ^= rkeys[i]
        state = inv_mix_columns(state)

    # final round
    state = inv_shift_rows(state)
    state = inv_sub_bytes(state)
    state ^= rkeys[0]

    return state.reshape(Text.shape)


def encrypt(pt: Text, key: Key) -> Text:
    """Encrypt a plain text block."""
    nk = len(key)
    assert nk in (4, 6, 8)
    rkeys = key_expansion(key)
    return cipher(pt, rkeys)


def decrypt(ct: Text, key: Key) -> Text:
    """Decrypt a plain text block."""
    nk = len(key)
    assert nk in (4, 6, 8)
    rkeys = key_expansion(key)
    return inv_cipher(ct, rkeys)
